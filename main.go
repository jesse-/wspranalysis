// This is a Go program that queries the wspr.live database for reception reports
// of a specific transmitter. It can then be used to rank the transmitter's
// effectiveness against other transmitters.

package main

import (
	"cmp"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"maps"
	"net/http"
	"net/url"
	"os"
	"slices"
	"strings"
	"time"

	"golang.org/x/exp/constraints"
)

// Base URL for querying the wspr.live database.
const baseQueryURL string = "https://db1.wspr.live/?query="

// Mapping of band names to their integer codes as used by wspr.live.
type bandNameToCodeType map[string]int

var bandNameToCode = bandNameToCodeType{
	"LF":   -1,
	"MF":   0,
	"160m": 1,
	"80m":  3,
	"60m":  5,
	"40m":  7,
	"30m":  10,
	"20m":  14,
	"17m":  18,
	"15m":  21,
	"12m":  24,
	"10m":  28,
	"6m":   50,
	"4m":   70,
	"2m":   144,
	"70cm": 432,
	"23cm": 1296,
}

// Return the band names sorted by their integer codes.
func (m bandNameToCodeType) bandNames() []string {
	names := slices.SortedFunc(maps.Keys(m), func(a, b string) int {
		return cmp.Compare(m[a], m[b])
	})
	return names
}

// Helper function to calculate the median of an optionally pre-sorted slice.
// NOTE: If preSorted is false, the input slice will be sorted in place.
func median[T interface {
	constraints.Integer | constraints.Float
}](values []T, preSorted bool) (float64, error) {
	if len(values) == 0 {
		return 0, fmt.Errorf("cannot calculate median of empty slice")
	}
	if !preSorted {
		slices.Sort(values)
	}
	if len(values) == 1 {
		return float64(values[0]), nil
	} else if len(values)%2 == 0 {
		midIndexA := len(values)/2 - 1
		midIndexB := len(values) / 2
		return (float64(values[midIndexA]) + float64(values[midIndexB])) / 2, nil
	} else {
		midIndex := len(values) / 2
		return float64(values[midIndex]), nil
	}
}

// Build a query URL to ask wspr.live for all the reception reports of the
// target transmitter within the specified time range. Additionally, list all
// the other transmitters which were received alongside the target transmitter.
//
//	txSign: Callsign of the target transmitter.
//	band: Integer code of the band (see bandNameToCode above and
//	      https://wspr.live/ under 'Bands Table').
//	tStart: Start time for the query.
//	duration: Query for reception reports up to duration after tStart.
func buildQueryUrl(txSign string, band int, tStart time.Time, duration time.Duration) string {
	// The outer SQL query just selects the desired columns for the specified
	// band and time range (this will include all transmitters and receivers).
	query := fmt.Sprintf("SELECT tx_sign, rx_sign, time, power, distance, rx_azimuth, snr FROM wspr.rx AS R WHERE "+
		"band = %d AND "+
		"time >= '%s' AND "+
		"time < '%s' AND "+
		// This nested EXISTS query filters the results with the condition that the
		// same receiver must also have received the target transmitter at the same
		// time and on the same band.
		"EXISTS (SELECT 1 FROM wspr.rx AS S WHERE S.tx_sign = '%s' AND S.band = %d AND S.rx_sign = R.rx_sign AND S.time = R.time) "+
		"ORDER BY time ASC, rx_sign ASC FORMAT JSON",
		band, tStart.UTC().Format(time.DateTime), tStart.UTC().Add(duration).Format(time.DateTime), txSign, band)
	return baseQueryURL + url.PathEscape(query)
}

// Struct to hold a WSPR reception report of the type generated by the above query.
type ReceptionReport struct {
	TimeStr     string `json:"time"`
	RxSign      string `json:"rx_sign"`
	TxSign      string `json:"tx_sign"`
	Power_dBm   int8   `json:"power"`
	Snr_dB      int8   `json:"snr"`
	Distance_km uint16 `json:"distance"`
	RxAzimuth   uint16 `json:"rx_azimuth"`
}

// Method for receptionReport to return the time as a time.Time object.
func (r *ReceptionReport) Time() time.Time {
	t, err := time.Parse(time.DateTime, r.TimeStr)
	if err != nil {
		return time.Time{}
	}
	return t
}

// Method for receptionReport to return the normalised SNR. This is the SNR that
// the receiver would have seen had the transmit power been txRefPower dBm.
func (r *ReceptionReport) SnrNorm_dB(txRefPower_dBm int8) int8 {
	return r.Snr_dB + txRefPower_dBm - r.Power_dBm
}

// Struct to hold a group of reception reports received by the same receiver
// at the same time. The TargetIndex field indicates the index within the Reports
// slice of the report corresponding to the target transmitter.
type ReceptionReportGroup struct {
	RxSign      string
	Time        time.Time
	Reports     []ReceptionReport
	TargetIndex int
}

func newReceptionReportGroup(reports []ReceptionReport, targetCallsign string) (*ReceptionReportGroup, error) {
	newGroup := new(ReceptionReportGroup)
	if len(reports) > 0 {
		newGroup.RxSign = reports[0].RxSign
		newGroup.Time = reports[0].Time()
		newGroup.Reports = reports
		newGroup.TargetIndex = -1
		for i, report := range newGroup.Reports {
			if report.TxSign == targetCallsign {
				newGroup.TargetIndex = i
				break
			}
		}
		if newGroup.TargetIndex == -1 {
			return nil, fmt.Errorf("target transmitter %s not found in report group for receiver %s at time %s",
				targetCallsign, newGroup.RxSign,
				newGroup.Time.UTC().Format(time.RFC3339))
		}
	}
	return newGroup, nil
}

// Perform the actual HTTP GET request to wspr.live and unmarshal the JSON
// response into a list of ListElementStructs.
func runQuery[ListElementStruct any](queryURL string) ([]ListElementStruct, error) {
	resp, err := http.Get(queryURL)
	if err != nil {
		return nil, fmt.Errorf("http.Get() failed (%w)", err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body (%w)", err)
	}
	// fmt.Println(string(body)) // Uncomment for debugging
	var receiverStruct struct {
		Data []ListElementStruct `json:"data"`
	}
	if err := json.Unmarshal(body, &receiverStruct); err != nil {
		return nil, fmt.Errorf("failed to decode JSON (%w)", err)
	}
	return receiverStruct.Data, nil
}

// Get the reception reports for the specified target callsign, band and time range.
// Reports for other transmitters received alongside the target callsign are also included
// (see buildQueryUrl()). This function groups the reports into chunks associated with a
// particular receiver and time. Within each chunk, the reports are ordered by descending
// normalised SNR. The normalised SNR is based on a notional transmit power of normTxPower_dBm.
// The function returns a slice of slices of receptionReport structs, with each inner slice
// containing the reports for a particular receiver and time. The outer slice is ordered by
// time followed by receiver callsign.
func getRxReports(targetCallsign string, band int, startTime time.Time, duration time.Duration, normTxPwr_dBm int8) ([]ReceptionReportGroup, error) {
	// Run the database query to get all the relevant reception reports in rawRxReports.
	rawRxReports, err := runQuery[ReceptionReport](buildQueryUrl(targetCallsign, band, startTime, duration))
	if err != nil {
		return nil, fmt.Errorf("error running database query on wspr.live (%w)", err)
	}
	if len(rawRxReports) == 0 {
		return nil, fmt.Errorf("no reception reports found for %s on band %d in the specified time range", targetCallsign, band)
	}
	// rawRxReports is one-dimensional and is ordered by time, followed by receiver callsign.
	// We need to split it each time the time or receiver field changes and build a
	// ReceptionReportGroup struct.
	var rxReports []ReceptionReportGroup
	for i, j := 0, 1; j <= len(rawRxReports); j++ {
		if j == len(rawRxReports) ||
			rawRxReports[j].TimeStr != rawRxReports[i].TimeStr ||
			rawRxReports[j].RxSign != rawRxReports[i].RxSign {
			// The slice rawRxReports[i:j] forms a report group.
			reportsForGroup := rawRxReports[i:j]
			// Sort it by descending normalised SNR.
			slices.SortFunc(reportsForGroup, func(a, b ReceptionReport) int {
				return cmp.Compare(b.SnrNorm_dB(normTxPwr_dBm), a.SnrNorm_dB(normTxPwr_dBm))
			})
			// Build a ReceptionReportGroup struct and append it to rxReports.
			newGroup, err := newReceptionReportGroup(reportsForGroup, targetCallsign)
			if err != nil {
				return nil, err
			}
			if newGroup == nil || len(newGroup.Reports) == 0 {
				return nil, fmt.Errorf("generated nil/empty report group. This should not happen")
			}
			rxReports = append(rxReports, *newGroup)
			// Move to the next group.
			i = j
		}
	}
	return rxReports, nil
}

// Filter reception reports to remove transmitters whose distance from the
// receiver is significantly different from the target transmitter.
func filterRxReports(rxReports []ReceptionReportGroup, targetCallsign string) ([]ReceptionReportGroup, error) {
	var filteredReports []ReceptionReportGroup
	for _, reportGroup := range rxReports {
		// Find the distance of the target transmitter from the receiver in order to
		// establish upper and lower bounds on distance for comparable transmitters.
		targetReport := reportGroup.Reports[reportGroup.TargetIndex]
		// Define acceptable distance range as +/- 25% of target distance.
		var distanceMin_km uint16 = uint16(float64(targetReport.Distance_km) * 0.75)
		var distanceMax_km uint16 = max(uint16(float64(targetReport.Distance_km)*1.25), 50) // Make sure the max distance is at least 50km to avoid too narrow a window.
		// Build a new report group containing only the reports within the acceptable distance range.
		filteredListForGroup := make([]ReceptionReport, 0, len(reportGroup.Reports))
		for _, report := range reportGroup.Reports {
			if report.Distance_km >= distanceMin_km && report.Distance_km <= distanceMax_km {
				filteredListForGroup = append(filteredListForGroup, report)
			}
		}
		newReportGroup, err := newReceptionReportGroup(filteredListForGroup, targetCallsign)
		if err != nil {
			return nil, fmt.Errorf("error building filtered report group (%w)", err)
		}
		if newReportGroup == nil || len(newReportGroup.Reports) < 2 {
			fmt.Printf("Reports from %s at %s filtered out due to insufficient comparable transmitters\n", reportGroup.RxSign, reportGroup.Time.UTC().Format(time.RFC3339))
		} else {
			filteredReports = append(filteredReports, *newReportGroup)
		}
	}
	return filteredReports, nil
}

// Print out the reception reports nicely formatted to the console. Also perform some
// basic stats to show how the target transmitter compares with the rest.
func printReportsAndStats(rxReports []ReceptionReportGroup, targetCallsign string, normTxPwr_dBm int8, verbose bool) {
	var aggregatedRelativeSnrNorms []int8
	for _, reportGroup := range rxReports {
		fmt.Printf("Received by %s (distance %dkm) at %s:\n", reportGroup.RxSign, reportGroup.Reports[reportGroup.TargetIndex].Distance_km,
			reportGroup.Time.UTC().Format(time.RFC3339))
		for i, report := range reportGroup.Reports {
			if verbose {
				if i == reportGroup.TargetIndex {
					fmt.Printf("     -->")
				} else {
					fmt.Printf("        ")
				}
				fmt.Printf("%d: Transmitter: %s, Power: %ddBm, Distance: %dkm, RX Azimuth: %dÂº, SNR: %+ddB, Normalised SNR: %+ddB\n", i+1,
					report.TxSign, report.Power_dBm, report.Distance_km, report.RxAzimuth, report.Snr_dB, report.SnrNorm_dB(normTxPwr_dBm))
			}
			if i != reportGroup.TargetIndex {
				relativeSnrNorm := report.SnrNorm_dB(normTxPwr_dBm) - reportGroup.Reports[reportGroup.TargetIndex].SnrNorm_dB(normTxPwr_dBm)
				aggregatedRelativeSnrNorms = append(aggregatedRelativeSnrNorms, relativeSnrNorm)
			}
		}
		if len(reportGroup.Reports) > 1 {
			var medianSnrNorm_dB int8
			reports := reportGroup.Reports
			if len(reportGroup.Reports)%2 == 0 {
				medianSnrNorm_dB = (reports[len(reports)/2-1].SnrNorm_dB(normTxPwr_dBm) + reports[len(reports)/2].SnrNorm_dB(normTxPwr_dBm)) / 2
			} else {
				medianSnrNorm_dB = reports[len(reports)/2].SnrNorm_dB(normTxPwr_dBm)
			}
			targetSnrNorm := reports[reportGroup.TargetIndex].SnrNorm_dB(normTxPwr_dBm)
			targetSnrNorm_dBmedian := targetSnrNorm - medianSnrNorm_dB
			fmt.Printf("    %d out of %d transmitters; Normalised SNR: %+ddB, %+ddBmedian\n", reportGroup.TargetIndex+1, len(reports), targetSnrNorm, targetSnrNorm_dBmedian)
		}
	}
	fmt.Printf("\nOffset from median of relative normalised SNR of all other transmitters: ")
	if l := len(aggregatedRelativeSnrNorms); l > 1 {
		aggregatedMedian, _ := median(aggregatedRelativeSnrNorms, false)
		fmt.Printf("%+.1fdBmedian (%d samples)\n", -aggregatedMedian, l)
	}
}

func main() {
	// Get and check command line arguments/flags.
	defaultStartTimeStr := time.Now().UTC().Add(-24 * time.Hour).Format(time.RFC3339)
	normTxPwr_dBm := flag.Int("norm", 43, "Transmit power in dBm to normalise SNRs for. All reported SNRs will be adjusted to what they would be if the transmitter used this power.")
	startTimeStr := flag.String("start", defaultStartTimeStr, "`Start time` for the query in RFC3339 format")
	duration := flag.Duration("duration", 24*time.Hour, "Duration to analyse over, starting from the start time given with the -start flag (e.g., 24h, 30m)")
	verbose := flag.Bool("v", false, "Enable verbose output (list each transmitter heard by each receiver)")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [options] [target callsign] [band]\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Query the wspr.live database for reception reports of [target callsign] on [band].\n")
		fmt.Fprintf(os.Stderr, "Each reception report is ranked against other transmitters heard by the same receiver\n")
		fmt.Fprintf(os.Stderr, "at the same time.\n\n")
		fmt.Fprintf(os.Stderr, "[band] is one of:\n\t%v\n\n", bandNameToCode.bandNames())
		fmt.Fprintf(os.Stderr, "Other options:\n")
		flag.PrintDefaults()
	}
	flag.Parse()
	if flag.NArg() != 2 {
		flag.Usage()
		return
	}
	targetCallsign := strings.ToUpper(flag.Args()[0])
	band, bandValid := bandNameToCode[strings.ToLower(flag.Args()[1])]
	if !bandValid {
		flag.Usage()
		return
	}
	startTime, err := time.Parse(time.RFC3339, *startTimeStr)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing start time: %v", err)
		return
	}
	if *normTxPwr_dBm < -128 || *normTxPwr_dBm > 127 {
		fmt.Fprintf(os.Stderr, "Error: Normalised transmit power must be between -128 and 127 dBm\n")
		return
	}

	// Should now have the following parameters:
	// fmt.Println("txCallsign:", targetCallsign)
	// fmt.Println("band:", band)
	// fmt.Println("verbose:", *verbose)
	// fmt.Println("startTime:", startTime.UTC().Format(time.RFC3339))
	// fmt.Println("duration:", *duration)
	// fmt.Println("normTxPwr_dBm:", int8(*normTxPwr_dBm))

	// Run the database query and get the results.
	rxReports, err := getRxReports(targetCallsign, band, startTime, *duration, int8(*normTxPwr_dBm))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting reception reports: %v", err)
		return
	}
	fmt.Printf("Found %d reception reports for %s on band %d from %s to %s\n",
		len(rxReports), targetCallsign, band, startTime.UTC().Format(time.RFC3339),
		startTime.UTC().Add(*duration).Format(time.RFC3339))

	// Do some filtering so that reports are comparable.
	rxReports, err = filterRxReports(rxReports, targetCallsign)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error filtering reception reports: %v", err)
		return
	}
	fmt.Printf("\n%d reception reports remain after filtering:\n", len(rxReports))

	// Print out the reception reports, grouped by time and receiver.
	printReportsAndStats(rxReports, targetCallsign, int8(*normTxPwr_dBm), *verbose)
}
